== Mogućnosti Vejna

Vejn je UI frejmvork koji služi za pisanje jednostraničnih veb-aplikacija u TajpSkriptu.
Uz frejmvork dolazi CLI i bandler sa optimizatorom, pa se ne javlja potreba za instaliranjem drugih paketa i podešavanjem sistema za kreiranje produkcionog bilda.

=== Šabloni

Svaki UI frejmvork mora da pruži podršku za definisanje korisničkog interfejsa.
Glavni zadatak frejmvorka je da pogled sa kojim korisnik interaguje održava sinhronizovanim sa model, tj. internim stanjem aplikacije.

////
TODO OVO TREBA DA IDE U DEO GDE SE OBJAŠNJAVA KAKO VEJN RADI

Ovaj zadatak sam po sebi ne predstavlja veliki izazov, ali stvari postaju znatno komplikovanije kada se uvrsti nekoliko drugih zahteva.

- Koliko se često ažurira pogled?
- Koliko je efikasno njegovo ažuriranje?
- Šta sve developer treba da uradi kako bi se ažuriranje dogodilo?
- Koji su preduslovi koje strukture podataka moraju da ispune da bi se promena detektovala?

Dati odgovre na ova pitanja znači uporediti UI frejmvorke. 
////

U Vejnu se interfejs definiše kroz deklarativnu sintaksu.
Ova sintaksa podseća na HTML kako bi se developer osećao "`kod kuće`", ali se zapravo radi o proizvoljnoj **šablonskoj sintaksi**.

==== Korišćenje HTML-a

Šablonska sintaksa je nadskup HTML-a.
To znači da svaki validan HTML predstavlja validan Vejn šablon, ali ne i obrnuto.

==== Vezivna sintaksa

Sprega između modela i pogleda postiže se vezivnom sintaksom -- ona je glavni razlog za proširenje HTML-a.
Vezivna sintaksa nudi svega nekoliko različitih konstrukcija.

- **Literal** se definiše pukim navođenjem.
Među literale spadaju stringovi (`"foo"`, `'foo'`), brojevi (`21`, `0x3`), logičke konstante (`true` i `false`), `null` i `undefined`.
- Mogu se referencirati **svojstva** sa klase za koju je šablon vezan ili alijasi koje izlaže direktiva u određenom opsegu, kao i **lanci pristupa** (`item`, `item.name`).
- Sem svojstava, mogu se referencirati i metode u **pozivima**. Argumenti se navode u malim zagradama, odvojeni zarezom -- kao i u Javaskriptu. Pored literala i svojstava, kao argument se može navesti i specijalan simbol `#` koji označava preuzimanje reference koja se prosleđuje kroz događaj (iz HTML elementa) ili izlaz (iz komponente).

Proizvoljni Javaskript izrazi nisu dozovljeni u vezivnoj sintaksi.
Na primer, ne može se vezati izraz kao `user && user.name` ili `name.length > 0`.
Ukoliko developer želi da u šablonu veže kompleksni izraz koji se računa na osnovu postojećih podataka iz modela, treba da koristi getere na klasi.

==== Interpolacija

Osnovni vid vezivanja modela jeste ispisivanje stringa na pogled.
Na primer, ovo može biti korisničko ime prijavljenog korisnika.
Vezivna sintaksa se piše između para dvostrukih vitičastih zagrada.

[source, html]
----
Welcome, {{ username }}!
----

==== HTML elementi

Kao što je već rečeno, Vejn šabloni su nadskup HTML-a.


=== Komponente

==== Deklaracija

==== Pristupna komponenta

==== Korišćenje

==== Ulazi i izlazi

============================================ BULLSHIT

Kao i kod svih UI frejmvorka, glavna gradivna jedinica je _komponenta_.
Komponente predstavljaju izolovane logičke celine koje se mogu smestiti u korisnički interfejs.

Komponentu treba shvatiti kao prirodnu nadogradnju HTML postojećih HTML elemenata.
Na primer, HTML element `HTMLInputElement` ima svoje **ime** na osnovu kojeg se prepoznaje u HTML kodu (`input`), ima neka **svojstva** na osnovu kojih može da se kontrolišu finese njegovog ponašanja i izgleda koja se mogu specificirati navođenjem HTML atributa ili direktnom manipulacijom kad odgovarajućim propertijima JavaSkript objekta (npr. `type`), i emituje neke **događaje** uz informaciju o tim događajima na koje se potrošači mogu pretplati i reagovati na njih.

Kao što se HTML-om definiše stablo elemenata, u Vejnu se od komponenti pravi stablo komponenti.
U korenu takvog stabla leži posebna komponetna koja se naziva **pristupna komponenta** (_entry component_).

Pristupnu komponetu treba smestiti u datoteku `index.ts` u folderu `src` i načiniti je podrazumevanim izvozom iz modula -- ovako će je Vejn prepoznati kao ulaznu tačku u aplikaciju.
Kada se aplikacija pokrene, renderuje se ova komponenta, a ona za sobom povlači sve druge komponente kroz svoj šablon.

Komponente se u Vejnu definišu klasom nad kojom je primenjen dekorator `@Template`.
Prvi i jedini argument dekoratora je string kojim se definiše struktura korisničkog interfejsa komponente.

Za stanje komponente koristi se telo klase, gde se standardno mogu definisati atributi i metode.
Svi atributi i metode su dostupne za referenciranje u šablonu.

// ===== Ime

Za razliku od HTML elemenata, koji su uvek globalno dostupni, komponente je potrebno **registrovati** za komponentu kako bi moglo da joj se pristupi iz templejta.
Registracija se vrši navođenjem reference na odgovarajuću klasu među argumentima dekoratora `@Register` koji se navodi uz klasu.
Ime simbola pod kojim se klasa registruje mora ima veliko početno slovo (tzv. _PascalCase_) kako bi se obezbedilo da neće doći do preklapanja sa imenima postojećih HTML elemenata i potencijalnih veb komponenti koje su registrovane na istoj stranici.

Osim razlike u malim i velikim slovima, postoji još jedna bitna razlika kod korišćenja komponenti u templejtima: simbolička imena za istu klasu (pa samim tim istu komponentu) mogu da se razlikuje među upotrebama u različitim komponenatama.
Drugim rečima, ime koje developer da simbolu prilikom registracije je ono pomoću koga komponenta može da se deklariše u templejtu.
Na primer, klasa se može preimenovati alijasovanim importom; pored toga, klasa uopšte ne mora da ima ime ukoliko je iz modula izvezena kao podrazumevani simbol, već joj se simboličko ime dodeljuje tek prilikom uvoza.

Registrovana komponenta se u šablon može postaviti kao bilo koji drugi HTML element.
Pošto ne može da ima decu, može se koristiti i samo-zatvarajući tag.

[source, xml]
----
<Component></Component>
<Component/>
----

//===== Ulazi

Da bi komponentu bilo moguće parametrizovati, uvodi se pojam **ulaza** (_input_) u komponentu.
Ovaj pojam je pandam svojstvima koje imaju HTML elementi.

Ulazi u komponentu se definišu deklarisanjem javnog svojstva na klasi.

Pošto se za proveru ispravnosti tipova u izvornom kodu koristi strogi režim TajpSkripta, ulazima za koje se očekuje da uvek dobiju vrednost iz šablona u kome se koriste dodaje se `!` -- stoga, ovo označava **obavezni ulaz**, pa Vejn prijavljuje grešku ukoliko mu se vrednost ne prosledi.
Za bi se definisala podrazumevana vrednost ulaza, dovoljno je da se svojstvo jednostavno inicijalizuje.
Ulazi sa podrazumevanom vrednošću ne mogu biti obavezni.

[source]
----
@Template(`...`)
class ExampleComponent {
  public input1!: number // <1>
  public input2 = 5      // <2>
  input3: any            // <3>
  private prop1: anz     // <4>
}
----
<1> Eksplicitno definisan obavezni ulaz.
<2> Eksplicitno definisan opcioni ulaz sa podrazumevanom vrednošću `5`.
<3> Implicitno definisan ulaz.
<4> Obično svojstvo na klasi koje se može iskoristiti za čuvanje stanja komponente.

U šablonima, ulazi se koriste kao da je u pitanju bilo koji HTML atribut, s tim što se ime ulaza omeđuje parom uglastih zagrada, a umesto konkretne vrednosti se očekuje **vezivna sintaksa**.


[source, html]
----
<ExampleComponent>
----

Osim vezivanja za svojstva klase, veza se može ostvariti i sa alijasima, ukoliko se u šablonu koriste direktive koje ih stvaraju.
Više reči o tome u odeljku o `w:for` direktivi.

//===== Izlazi

HTML elementi imaju događaje, a Vejn komponente imaju **izlaze** (_output_).
Izlaz se deklariše kao metoda bez tela u telu klase.
Da bi se izlaz komponente osluškivao, dodaje se HTML atribut, pri čemu je ime izlaza omeđeno parom oblih zagrada, a umesto prosleđivanja konkretne vrednosti se očekuje **poziv funkcije**, tj. metode definisane u klasi.

Da bi se pribavila referenca na vrednosti koje se emituju kroz izlaz, u šablonu se koristi specijalni znak `#` kao argument funkcije.
Pored njega, argumenti funkcije se mogu referencirati na svojstva klase ili mogu biti literali.

////
Sledi primer koji pokriva razne elemente defincije komponente.

[source]
----
import { Register, Template } from 'wane'

@Register(Circle)
@Template(`
  <button (click)="dec()">-1</button>
  <button (click)="inc()">+1</button>
  <Circle
    [content]="value"
    [class]="color"
  />
`)
class Foo {
  public value!: number
  public color = 'red'

  public valueChange (newValue: number) { }

  private get valueAsText () {
    return this.value == 0 ? 'Nothing' : this.value.toString()
  }
}
----
////

=== Pokretanje

wane binexec iz nodemodules

prod build, dist folder

config fajl

dev server
