\section{Fabrike direktive za ponavljanje (\code{w:for})}
\label{sec:fabrike-direktive-za-ponavljanje}

Konceptualno, direktiva za ponavljanje funkcioniše isto kao i uslovna direktiva -- sastoji se iz dva dela, pri čemu se unutrašnji deo takođe zove \textbf{parcijalni poged} i ima identičnu strukturu kao i parcijalni pogled vezan za uslovnu direktivu, a spoljni deo \textbf{ponavljajući pogled} (\textsl{repeating view}).

Struktura ponavljajućeg pogleda je, međutim, znatno drugačija od strukture uslovnog pogleda.
Sadrži najdinamičniji deo koda iz celog frejmvorka; zbog prirode direktive nemoguće mnogo stvari odrediti statički jer je nemoguće predvideti kako će se dodavati elementi u niz, brisati iz njega, i kako će menjati mesta.
Ovo je verovatno najneoptimalniji deo generisanog koda, pa se u poređenju sa ostatakom može učiniti kao previše glomazan, ali se zapravo bazira na konceptima traženje razlike između dva niza i sličan je algoritmima za \textit{dom diff} koji koriste mnoge biblioteke.
Konkretno je inspirisan funkcijom za traženje i \textquote{krpljenje} razlika iz jedne od ranijih verzija mikro-frejmvorka \textit{Hyperapp}~\cite{hyperapp:patch}.

TODO: objasni algoritam, trebaće neke jednostavne slike... nabrzaka: ideja je da se prolazi kroz oba niza paralelno u nadi da će da se pronađu odgovarajući elementi (to znači da im je isti ključ) u starom nizu kada se naiđe na novi niz. na elementu u novom nizu se stoji sve dok se ne naiđe na isti element u starom nizu, pri čemu se u hešu (tj javaskript objektu što nije baš O(1) ali je dovoljno blizu) čuvaju svi obiđeni elementi da bi lako moglo da im se pristupi kasnije (da ne moramo da prolazimo kroz niz dvaput). kada prođemo kroz ceo stari niz, ako nema tog elementa kog tražimo, kreiramo ga. sada barem imamo sve elemente u hešu i lako je da im pristupimo pa samo cepamo kroz novi niz i ili radimo move elementa kad je pogodak ili ga stvorimo kad je pronašaj. sve vreme pratimo gde se trenutno nalazimo u DOM-u (ne samo gde smo u novom i starom nizu) da bismo znali da insertBeforeujemo na mesto gde treba. poslednji element ne ide insertBefore nad nekim elementom nego ide na closing outlet celog w:fora. malo je nezgodno da se celo objasni onako striktno ali uz jednostavne primere koji ilustruju par ključnih slučejeva, neki edge case i jedan-dva kompletna primera koji ilustruju ceo obilazak i rezonovanje, i naravno pre svega toga idejno rešenje bi trebao da bude dovoljno jasno
